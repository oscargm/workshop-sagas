(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{406:function(e,t,a){"use strict";a.r(t);var n=a(0),l=a.n(n),s=a(37),c=a(113),o=a(111),r=a(112),i=a(101),u=a(402),f=a(404),m=a(405),d=a(403);t.default=function(){return l.a.createElement("div",null,l.a.createElement(u.a,{active:"effects"}),l.a.createElement(o.a,{fontSize:5},"Effects"),l.a.createElement(o.a,{fontSize:3},"Setup"),l.a.createElement(r.a,null,"Clone the repo in"," ",l.a.createElement(s.c,{href:"https://github.com/Limenius/workshop-sagas"},"https://github.com/Limenius/workshop-sagas")," ","with:"),l.a.createElement(m.a,null,"git clone https://github.com/Limenius/workshop-sagas.git"),l.a.createElement(r.a,null,"and run:"),l.a.createElement(m.a,null,"yarn install"),l.a.createElement(m.a,null,"yarn start"),l.a.createElement(r.a,null,"You should see three button (only one does something at this point)"),l.a.createElement(r.a,null,"If we look into ",l.a.createElement("code",null,"src/makeStore.js")," you should see this code:"),l.a.createElement(i.a,{code:a(424)}),l.a.createElement(r.a,null,'This is the basic setup of redux-saga, we define a "root saga", which will be our entry point. This root saga looks like this:'),l.a.createElement(i.a,{code:a(425)}),l.a.createElement(r.a,null,"And, if we have a look into the console, we will see that the saga is executing. Although it is not doing much. It is a start, though."),l.a.createElement(o.a,{fontSize:3},"Structure of this playground"),l.a.createElement(r.a,null,"Let's examine the reducer and the idea behind this playground project"),l.a.createElement(r.a,null,"We have a reducer ",l.a.createElement("code",null,"src/reducrs/tasks"),", that holds an array of tasks."),l.a.createElement(r.a,null,"Tasks have this structure: ",l.a.createElement("code",null,"{","name, status}"),". A name, that will be randomly generated and will be a unique identifier. And a status, which describes the situation of the task."),l.a.createElement(r.a,null,"The possible 4 available status are ",l.a.createElement("code",null,"IDLE"),","," ",l.a.createElement("code",null,"STARTED"),", ",l.a.createElement("code",null,"DONE")," and ",l.a.createElement("code",null,"FAILED"),"."),l.a.createElement(r.a,null,"We have some action types in ",l.a.createElement("code",null,"src/actions/constants"),"."),l.a.createElement(r.a,null,l.a.createElement("code",null,"TASK_CREATE"),': creates a task, if we press the button "Create a task!" and we inspect it in the Redux debugger we will see how it is dispatched. This task is handled by the reducer directly and we don\'t need to react upon it, but it has the same structure as other important tasks: It takes the name of the task as a parameter.'),l.a.createElement(r.a,null,"Then we have a typical structure of 4 actions to process a request with Redux Saga."),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("code",null,"TASK_PROCESS"),":"," ",l.a.createElement(r.a,null,"This will be handled by sagas as a signal to start processing the task with the provided name.")),l.a.createElement("li",null,l.a.createElement("code",null,"TASK_PROCESS_START"),":"," ",l.a.createElement(r.a,null,"The saga will dispatch this action before start processing the task with the provided name. The reducer will update the task, and visually this allows us to show a spinner.")),l.a.createElement("li",null,l.a.createElement("code",null,"TASK_PROCESS_DONE"),":"," ",l.a.createElement(r.a,null,"If the task is fullfilled, sagas will dispatch this action to mark its completion. The reducer will process it to update the task.")),l.a.createElement("li",null,l.a.createElement("code",null,"TASK_PROCESS_RESET"),":"," ",l.a.createElement(r.a,null,"If the task fails, sagas will dispatch this action to signify that an error has ocurred. The reducer will process it to update the task."))),l.a.createElement(o.a,{fontSize:3},"Basic effects"),l.a.createElement(r.a,null,"Let's play with our sagas!"),l.a.createElement(r.a,null,"We have our generator rootSaga in ",l.a.createElement("code",null,"src/rootSaga.js"),". It is a"," ",l.a.createElement("code",null,"function*")," so, a generator, but it is not ",l.a.createElement("code",null,"yield"),"ing anything. What a waste! But... what to yield?"),l.a.createElement(r.a,null,"In redux sagas we communicate with our runner by yielding a set of instructions that ",l.a.createElement("i",null,"describe")," what we to do. We call these instructions ",l.a.createElement("i",null,"effects"),". Every one of these effects is a function that will return an object that describes an instruction. Let's see a first example:"),l.a.createElement(o.a,{fontSize:3},"Take"),l.a.createElement(r.a,null,l.a.createElement("code",null,"Take")," ",l.a.createElement("b",null,"blocks")," until an action of a given type is dispatched. Then, returns that action."),l.a.createElement(r.a,null,'We can read it as "hey! I want to wait here until this action is dispatched!"'),l.a.createElement(r.a,null,"Let's write the following code in our root saga to test it:"),l.a.createElement(i.a,{code:'export function* rootSaga() {\n  console.log("hi from sagas");\n  const action = yield effects.take(constants.TASK_PROCESS);\n  console.log("Yay! action received: ", action);\n}'}),l.a.createElement(r.a,null,"Create a task in the UI and press the button ",l.a.createElement("b",null,"Start"),". Do you see the log message in the console?"),l.a.createElement(r.a,null,"Try this instruction"," ",l.a.createElement("code",null,"console.log(effects.take(constants.TASK_PROCESS));")," to inspect the effect."),l.a.createElement(r.a,null,"That is, that is ",l.a.createElement("code",null,"take"),". Let's see its sister ",l.a.createElement("code",null,"put"),"."),l.a.createElement(o.a,{fontSize:3},"Put"),l.a.createElement(r.a,null,l.a.createElement("code",null,"Put")," dispatches an action. It is ",l.a.createElement("b",null,"non-blocking"),": it won't wait indefinitely for something to happen, the execution will continue."),l.a.createElement(i.a,{code:'export function* rootSaga() {\n    console.log("hi from sagas");\n    const action = yield effects.take(constants.TASK_PROCESS);\n    console.log("Yay! action received: ", action);\n    yield effects.put({ type: constants.TASK_PROCESS_START, name: action.name });\n    console.log("We just dispatched an action");\n}'}),l.a.createElement(r.a,null,"Examine in the console & the redux debugger that we are actually dispatching an action."),l.a.createElement(r.a,null,"This is a start, but we are just receiving an action and dispatching another, pretty useless still. What about the side effects? Wha about async code? Let's use ",l.a.createElement("code",null,"call"),". With these three building blocks we can start building very useful things already."),l.a.createElement(o.a,{fontSize:3},"Call"),l.a.createElement(r.a,null,"Although technically ",l.a.createElement("code",null,"call")," can do many things, the intuitive idea is very simple: Call ",l.a.createElement("i",null,"something"),", and ",l.a.createElement("b",null,"block")," until its execution is finished."),l.a.createElement(r.a,null,"Let's see an example. Uncomment the function"," ",l.a.createElement("code",null,"processTaskTimeConsumingReal"),", which makes an Ajax call and returns a promise:"),l.a.createElement(i.a,{code:'export function* rootSaga() {\n  console.log("hi from sagas");\n  const action = yield effects.take(constants.TASK_PROCESS);\n  console.log("Yay! action received: ", action);\n  yield effects.put({ type: constants.TASK_PROCESS_START, name: action.name });\n  console.log("We just dispatched an action");\n  console.log("Making a request... this takes time");\n  yield effects.call(processTaskTimeConsumingReal);\n  console.log("Request finished!");\n}'}),l.a.createElement(r.a,null,"If we try this piece of code, we will see that ",l.a.createElement("code",null,"call")," executes the function. This function returns a promise, so call will wait until the promise is fullfilled (or fails), and will give us the value returned, if any."),l.a.createElement(r.a,null,"We could pass arguments to the function called adding arguments to call:"," ",l.a.createElement("code",null,"yield effects.call(processTaskTimeConsumingReal, arg1, arg2);")),l.a.createElement(d.a,{code:'  console.log("Request finished!");\n  yield effects.put({ type: constants.TASK_PROCESS_DONE, name: action.name });\n}'},"Go ahead and PUT the action"," ",l.a.createElement("code",null,"{"," type: constants.TASK_PROCESS_DONE, name: action.name }")," ","after the request has finished. Use it in the browser, it should be able to show a task a completed."),l.a.createElement(o.a,{fontSize:3},"The real world is a dangerous place"),l.a.createElement(r.a,null,"An important part of dealing with the external world (side-effects) is dealing with its imperfections. Things can fail, things can crash, things will crash, so we have to prevent these errors."),l.a.createElement(r.a,null,"Before we continue, remove or comment out"," ",l.a.createElement("code",null,"processTaskTimeConsumingReal"),", uncomment"," ",l.a.createElement("code",null,"processTaskTimeConsuming")," and use it instead. This is not a real request, it is a simulation, but will give us more control during this workshop."),l.a.createElement(r.a,null,l.a.createElement("code",null,"processTaskTimeConsuming")," is actually... a generator! That is right, ",l.a.createElement("code",null,"call")," can execute generators as well. And will block until their completion."),l.a.createElement(r.a,null,"There is a new effect in this generator: ",l.a.createElement("code",null,"delay"),". It... delays the execution a time in miliseconds. It is very useful in many cases."),l.a.createElement(d.a,{code:"export function* rootSaga() {\n  const action = yield effects.take(constants.TASK_PROCESS);\n  yield effects.put({ type: constants.TASK_PROCESS_START, name: action.name });\n  try {\n    yield effects.call(processTaskTimeConsuming);\n    yield effects.put({ type: constants.TASK_PROCESS_DONE, name: action.name });\n  } catch (error) {\n    yield effects.put({ type: constants.TASK_PROCESS_ERROR, name: action.name });\n  }\n}"},"Now, this call will fail 50% of the times. And the error propagates to"," ",l.a.createElement("code",null,"rootSaga"),". Can you handle the error in ",l.a.createElement("code",null,"rootSaga")," ","so if there is an exception you will gracefully put an action",l.a.createElement("code",null,"{"," type: constants.TASK_PROCESS_ERROR, name: action.name }")," ","?"),l.a.createElement(r.a,null,"Now this how we can process a request completely with error handling included in redux sagas."),l.a.createElement(r.a,null,"Still, we can only process one request, and then our generator is finished. Let's fix that."),l.a.createElement(r.a,null,"But first, let's refactor our code a bit:"),l.a.createElement(i.a,{code:"function* doProcessTask(name) {\n  yield effects.put({ type: constants.TASK_PROCESS_START, name });\n  try {\n    yield effects.call(processTaskTimeConsuming);\n    yield effects.put({ type: constants.TASK_PROCESS_DONE, name });\n  } catch (error) {\n    yield effects.put({ type: constants.TASK_PROCESS_ERROR, name });\n  }\n}\n\nexport function* rootSaga() {\n  const action = yield effects.take(constants.TASK_PROCESS);\n  yield effects.call(doProcessTask, action.name);\n}"}),l.a.createElement(r.a,null,"Wrap ",l.a.createElement("code",null,"rootSaga")," in a ",l.a.createElement("code",null,"while(true)"),":"),l.a.createElement(i.a,{code:"export function* rootSaga() {\n  while (true) {\n    const action = yield effects.take(constants.TASK_PROCESS);\n    yield effects.call(doProcessTask, action.name);\n  }\n}"}),l.a.createElement(f.a,null,l.a.createElement(r.a,null,"Backup:"," ",l.a.createElement(s.c,{href:"https://gist.github.com/nacmartin/b9853745f463b53cfd31126ed380cd61"},"this is a gist with the code at this point"))),l.a.createElement(r.a,null,"Ok, now we can, ",l.a.createElement("i",null,"sequentially"),", process tasks, but one at a time. Why? because ",l.a.createElement("b",null,"call")," is blocking. This may be what we want in some cases, but most times we would prefer not to block here. We can fix this easily, with a new, powerful, effect."),l.a.createElement(o.a,{fontSize:3},"Fork"),l.a.createElement(r.a,null,l.a.createElement("code",null,"Fork")," behaves like ",l.a.createElement("code",null,"call")," but it is non-blocking. Try replacing ",l.a.createElement("code",null,"call")," by fork in ",l.a.createElement("code",null,"rootSaga"),":"),l.a.createElement(i.a,{code:"export function* rootSaga() {\n  while (true) {\n    const action = yield effects.take(constants.TASK_PROCESS);\n    yield effects.fork(doProcessTask, action.name);\n  }\n}"}),l.a.createElement(r.a,null,"This pattern is so common, that has his own higher order effect."),l.a.createElement(o.a,{fontSize:3},"TakeEvery"),l.a.createElement(r.a,null,l.a.createElement("code",null,"takeEvery(PATTERN, saga, ...args)")," takes the name of the action (or more complex patterns, see the docs for that) as first argument, and the saga to fork as second"),l.a.createElement(r.a,null,"Try this:"),l.a.createElement(i.a,{code:"function* processTask(action) {\n  yield effects.call(doProcessTask, action.name);\n}\n\nexport function* rootSaga() {\n  yield effects.takeEvery(constants.TASK_PROCESS, processTask);\n}"}),l.a.createElement(r.a,null,"We have now, ",l.a.createElement("code",null,"proccessTask")," and ",l.a.createElement("code",null,"doProcessTask")," ","because the first one has the action as argument, and the later the string"," ",l.a.createElement("code",null,"name"),"."),l.a.createElement(o.a,{fontSize:3},"Cancelling sagas"),l.a.createElement(r.a,null,"The ability to cancel sagas is a very powerful feature. Let's try this:"),l.a.createElement(i.a,{code:"export function* rootSaga() {\n  while (true) {\n    const action = yield effects.take(constants.TASK_PROCESS);\n    const saga = yield effects.fork(doProcessTask, action.name);\n    yield effects.delay(500);\n    yield effects.cancel(saga);\n  }\n}"}),l.a.createElement(r.a,null,"This is not very useful, but it is illustrative. ",l.a.createElement("code",null,"cancel")," ","cancels another saga, that has been forked, along with its forks, if any."),l.a.createElement(r.a,null,"Now we are cancelling 500ms after forking, stopping"," ",l.a.createElement("code",null,"doProcessTask"),", which leaves us with an infinite spinner."),l.a.createElement(r.a,null,"We can know in the child saga if it has been cancelled, using"," ",l.a.createElement(i.a,{code:"try{\n    ...\n} finally {\n  if (yield effects.cancelled()) {\n   // do something useful\n  }\n}"})),l.a.createElement(d.a,{code:"function* doProcessTask(name) {\n  try {\n    yield effects.put({ type: constants.TASK_PROCESS_START, name });\n    yield effects.call(processTaskTimeConsuming);\n    yield effects.put({ type: constants.TASK_PROCESS_DONE, name });\n  } catch (error) {\n    yield effects.put({ type: constants.TASK_PROCESS_ERROR, name });\n  } finally {\n    if (yield effects.cancelled()) {\n      yield effects.put({ type: constants.TASK_PROCESS_RESET, name });\n    }\n  }\n}"},"Can you add a ",l.a.createElement("code",null,"finally")," clause that puts an action"," ",l.a.createElement("code",null,"{"," type: constants.TASK_PROCESS_RESET, name }")," in"," ",l.a.createElement("code",null,"doProcessTask")," to do some cleanup when the task is cancelled?"),l.a.createElement(o.a,{fontSize:3},"More higher order sagas: takeLatest, debounce, throttle"),l.a.createElement(r.a,null,"Let's go back to:"),l.a.createElement(i.a,{code:"export function* rootSaga() {\n  yield effects.takeEvery(constants.TASK_PROCESS, processTask);\n}"}),l.a.createElement(r.a,null,"As you know this is equivalent to"),l.a.createElement(i.a,{code:"export function* rootSaga() {\nwhile (true) {\n  const action = yield effects.take(constants.TASK_PROCESS);\n  yield effects.fork(doProcessTask, action.name);\n}"}),l.a.createElement(d.a,{code:"export function* rootSaga() {\n  while (true) {\n    const action = yield effects.take(constants.TASK_PROCESS);\n    yield effects.call(doProcessTask, action.name);\n  }\n}"},l.a.createElement(r.a,null,"Instead of ",l.a.createElement("code",null,"takeEvery")," try ",l.a.createElement("code",null,"takeLeading")),l.a.createElement(r.a,null,"Play a bit with it in the UI. We have seen this behaviour in the past, what piece of code was equivalent to this one?")),l.a.createElement(d.a,{code:"export function* rootSaga() {\n  let lastProcess;\n  while (true) {\n    const action = yield effects.take(constants.TASK_PROCESS);\n    if (lastProcess) {\n      yield effects.cancel(lastProcess);\n    }\n    lastProcess = yield effects.fork(doProcessTask, action.name);\n  }\n}"},l.a.createElement(r.a,null,"This is more interesting: try instead ",l.a.createElement("code",null,"takeLatest")),l.a.createElement(r.a,null,"Play a bit with it in the UI. What does it do? Can you implement it using low level effects?"),l.a.createElement(r.a,null,"Hint: You will need ",l.a.createElement("code",null,"cancel"),".")),l.a.createElement(d.a,{code:"export function* rootSaga() {\n  while (true) {\n    const action = yield effects.take(constants.TASK_PROCESS);\n    yield effects.fork(doProcessTask, action.name);\n    yield effects.delay(800);\n  }\n}"},l.a.createElement(r.a,null,"If you finished the last one early, can you play with"," ",l.a.createElement("code",null,"yield effects.throttle(800, constants.TASK_PROCESS, processTask);"),"and try to replicate it?")),l.a.createElement(r.a,null,"There is yet another effect in this family: ",l.a.createElement("code",null,"debounce"),", but this one is more difficult to express it in terms of low level effects. If you are curious you can have a look to the documentation of redux-saga, in the section API."),l.a.createElement(f.a,null,l.a.createElement(r.a,null,"Before proceeding to the next section, plase, set the content of this file to"," ",l.a.createElement(s.c,{href:"https://gist.github.com/nacmartin/520c8f84cc1031e0f75a1586d599d8b1"},"this state"))),l.a.createElement(o.a,{fontSize:4},"Effect combinators: race and all."),l.a.createElement(o.a,{fontSize:3},"Race"),l.a.createElement(r.a,null,l.a.createElement("code",null,"race")," is very interesting and useful in more cases that you may think of at a first glance."),l.a.createElement(r.a,null,"Take a look at this code. Try it in our sandbox. What is it doing?"),l.a.createElement(i.a,{code:"function* processTaskTimed(action) {\n  yield effects.race({\n    response: effects.call(doProcessTask, action.name),\n    timeout: effects.delay(1500)\n  });\n}\n\nexport function* rootSaga() {\n  yield effects.takeEvery(constants.TASK_PROCESS, processTaskTimed);\n}"}),l.a.createElement(r.a,null,"This is useful when we can have requests that may not have a response at all. For instance in Bluetooth communication, when we don't know if a package has been lost."),l.a.createElement(d.a,{code:"function* processTaskTimed(action) {\n  yield effects.race({\n    response: effects.call(doProcessTask, action.name),\n    timeout: effects.take(constants.TASK_PROCESS_CANCEL_ALL)\n  });\n}",code2:"function* processTaskTimed(action) {\n  yield effects.race({\n    response: effects.call(doProcessTask, action.name),\n    timeout: effects.delay(1500)\n    cancelled: effects.take(constants.TASK_PROCESS_CANCEL_ALL)\n  });\n}"},l.a.createElement(r.a,null,'There is a button that says "cancel all tasks!", that had no use... until now. It dispatches an action of type ',l.a.createElement("code",null,"TASK_CANCEL_ALL"),"."),l.a.createElement(r.a,null,"Can you cancel the processing of a task when this action is dispatched?")),l.a.createElement(d.a,{code:"// Remove the finally clause of doProcessTask and\nfunction* processTaskTimed(action) {\n  const res = yield effects.race({\n    response: effects.call(doProcessTask, action.name),\n    cancelled: effects.take(constants.TASK_PROCESS_CANCEL_ALL),\n    timeout: effects.delay(1500)\n  });\n  if (res.cancelled) {\n    yield effects.put({\n      type: constants.TASK_PROCESS_RESET,\n      name: action.name\n    });\n  }\n  if (res.timeout) {\n    yield effects.put({\n      type: constants.TASK_PROCESS_ERROR,\n      name: action.name\n    });\n  }\n}"},l.a.createElement(r.a,null,"Can you cancel the processing of a task when this action is dispatched OR there is a timeout?"),l.a.createElement(r.a,null,"Examine (console.log) what is the return value of"," ",l.a.createElement("code",null,"yield effects.race(","{",")")),'. Can you use it to determine which saga "won" the race and killed the other two?'),l.a.createElement(f.a,null,l.a.createElement(r.a,null,"Before proceeding to the next section, plase, set the content of this file to"," ",l.a.createElement(s.c,{href:"https://gist.github.com/nacmartin/f0ac84e939bf5b4346007666ca017aed"},"this state"))),l.a.createElement(o.a,{fontSize:3},"All (and select)"),l.a.createElement(r.a,null,l.a.createElement("code",null,"all")," is similar in syntax to ",l.a.createElement("code",null,"race"),", but its purpose is different: it will run all the effects and wait until all are complete (if they all are non blocking like for instance forks it will return immediately)."),l.a.createElement(r.a,null,'We can use it to implement the button "Process all tasks!"'),l.a.createElement(r.a,null,"We would like to retrieve all the tasks that are idle from the state. And start processing them. Can we access the state of redux?"),l.a.createElement(r.a,null,l.a.createElement("code",null,"select")," does exactly that. Let's see how to call it"),l.a.createElement(i.a,{code:"const tasks = yield effects.select(state =>\n  state.tasks.filter(task => task.state === constants.statuses.IDLE)\n);"}),l.a.createElement(r.a,null,l.a.createElement("code",null,"select")," accepts as a parameter a ",l.a.createElement("b",null,"selector"),". That is, a function that, given the state of redux, will return the data that we want to retrieve."),l.a.createElement(r.a,null,"We can do for instance this (Because of generators, ",l.a.createElement("code",null,"forEach")," ","won't work.) :"),l.a.createElement(i.a,{code:"function* processAll() {\n  const tasks = yield effects.select(state =>\n    state.tasks.filter(task => task.status === constants.statuses.IDLE)\n  );\n  for (let task of tasks) {\n    yield effects.fork(doProcessTask, task.name);\n  }\n}\n\n\nexport function* rootSaga() {\n  yield effects.takeEvery(constants.TASK_PROCESS, processTaskTimed);\n  yield effects.takeEvery(constants.TASK_PROCESS_ALL, processAll);\n}"}),l.a.createElement(r.a,null,"This runs the tasks sequentially, since they are forks, that are not blocking, they will run simultaneusly."),l.a.createElement(r.a,null,"But we can use ",l.a.createElement("code",null,"all")," as well:"),l.a.createElement(i.a,{code:"function* processAll() {\n  const tasks = yield effects.select(state =>\n    state.tasks.filter(task => task.status === constants.statuses.IDLE)\n  );\n  const effectsToRun = tasks.map(task =>\n    effects.fork(doProcessTask, task.name)\n  );\n  yield effects.all(effectsToRun);\n}"}),l.a.createElement(r.a,null,"What about cancellation? Can we cancel all these forks at once if we please?"),l.a.createElement(r.a,null,"The easiest thing we can do is to cancel ",l.a.createElement("code",null,"processAll")," instead. Let's see a pattern that becomes pretty useful:"),l.a.createElement(i.a,{code:"function* processAll() {\n  const tasks = yield effects.select(state =>\n    state.tasks.filter(task => task.status === constants.statuses.IDLE)\n  );\n  const effectsToRun = tasks.map(task =>\n    effects.fork(doProcessTask, task.name)\n  );\n  yield effects.all(effectsToRun);\n}\n\nfunction* watchCancel(allProccess) {\n  yield effects.take(constants.TASK_PROCESS_CANCEL_ALL);\n  yield effects.cancel(allProccess);\n}\n\nfunction* processAllController() {\n  while (true) {\n    yield effects.take(constants.TASK_PROCESS_ALL);\n    const allProcess = yield effects.fork(processAll);\n    yield effects.fork(watchCancel, allProcess);\n  }\n}\n\nexport function* rootSaga() {\n  yield effects.takeEvery(constants.TASK_PROCESS, processTaskTimed);\n  yield effects.fork(processAllController);\n}"}),l.a.createElement(o.a,{fontSize:3},"Spawn"),l.a.createElement(r.a,null,"We have a good opportunity now to see see fork's brother,"," ",l.a.createElement("code",null,"spawn"),"."),l.a.createElement(r.a,null,l.a.createElement("code",null,"spawn")," is like ",l.a.createElement("code",null,"fork")," but ",l.a.createElement("b",null,"detached"),". That is, cancelling the parent doesn't cancel the spawned saga, and if the spawned saga encounters an error, it won't bubble up to the parent."),l.a.createElement(r.a,null,"If we replace in ",l.a.createElement("code",null,"processAll")," the effect ",l.a.createElement("code",null,"fork")," for"," ",l.a.createElement("code",null,"spawn")),l.a.createElement(r.a,null,"Try this:"),l.a.createElement(i.a,{code:"\n      const effectsToRun = tasks.map(task =>\n        effects.spawn(doProcessTask, task.name)\n      );\n    "}),l.a.createElement(r.a,null,"And see how the cancellation doesn't propagate to the spawned processes."),l.a.createElement(o.a,{fontSize:4},"Channels"),l.a.createElement(o.a,{fontSize:3},"Action channels"),l.a.createElement(f.a,null,l.a.createElement(r.a,null,"Before continuing, plase, set the content of this file to"," ",l.a.createElement(s.c,{href:"https://gist.github.com/nacmartin/51493845c6a7bebaddd3dfb1a74fbaf3"},"this state"))),l.a.createElement(r.a,null,"ActionChannels act as a buffer, that hold actions so we can"," ",l.a.createElement("code",null,"take them"),", even if we are blocking while the action was produced."),l.a.createElement(r.a,null,"Check this out and see how it resembles to an elevator with memory. While it is processing a task, it is buffering the new actions."),l.a.createElement(i.a,{code:"export function* rootSaga() {\n  const requestChan = yield effects.actionChannel(\n    constants.TASK_PROCESS,\n  );\n  while (true) {\n    const action = yield effects.take(requestChan);\n    yield effects.call(processTask, action);\n  }\n}"}),l.a.createElement(r.a,null,"Check this code out and see how it resembles to an elevator with memory. While it is processing a task, it is buffering the new actions:"),"`",l.a.createElement(d.a,{code:'import { buffers } from "redux-saga";\n\n  const requestChan = yield effects.actionChannel(\n    constants.TASK_PROCESS,\n    buffers.sliding(1)\n  );\n  while (true) {\n    const action = yield effects.take(requestChan);\n    yield effects.call(processTask, action);\n  }\n}'},l.a.createElement(r.a,null,l.a.createElement("code",null,"actionChannel")," accepts a second argument, the type of buffer. For instance:"),l.a.createElement(i.a,{code:'import { buffers } from "redux-saga";\n\nexport function* rootSaga() {\n  const requestChan = yield effects.actionChannel(\n    constants.TASK_PROCESS,\n    buffers.none()\n  );\n  while (true) {\n    const action = yield effects.take(requestChan);\n    yield effects.call(processTask, action);\n  }\n}'}),l.a.createElement(r.a,null,"Would disable buffering (non taken actions will be lost)."),l.a.createElement(r.a,null,"But... how could you buffer one action, and when a new action comes, it replaces the current buffered action?"),l.a.createElement(r.a,null,"Note: we recommend to increase the time taken to process a task, like so:"),l.a.createElement(i.a,{code:"function* processTaskTimeConsuming() {\n  yield effects.delay(4000 + 1000 * Math.random());\n}"}),l.a.createElement(r.a,null,"Have a look at"," ",l.a.createElement(s.c,{href:"https://redux-saga.js.org/docs/api/#buffers"},"the documentation of buffers"))),l.a.createElement(o.a,{fontSize:3},"Event channels"),l.a.createElement(r.a,null,"So far our actions are caused, in a way or another, by the UI (or another saga, that is running because of the UI). The user clicks something, or a React component triggers an action when it mounts, or..."),l.a.createElement(r.a,null,"But sometimes we would like to have other sources of events. We may have a websocket connection. Or we may have a bluetooth connection."),l.a.createElement(r.a,null,"We would like to be able to emit actions from these sources too."),l.a.createElement(r.a,null,l.a.createElement("code",null,"eventChannel")," fulfills this need. It emits Events, and we can"," ",l.a.createElement("code",null,"take")," from the channel. Once we take the event, we can put an action, or do whatver we want."),l.a.createElement(r.a,null,"Run this command to start a node.js server that we have prepared for you. This will start a websocket server that will emit events of type"," ",l.a.createElement("code",null,"message")," with this shape every second:"),l.a.createElement(i.a,{code:'\n      {type: "create", name: "some_name"}\n    '}),l.a.createElement(m.a,null,"yarn start-server"),l.a.createElement(r.a,null,"Now run this code and we can discuss it:"),l.a.createElement(i.a,{code:'import * as effects from "redux-saga/effects";\nimport { END, eventChannel } from "redux-saga";\nimport * as constants from "../actions/constants";\nimport io from "socket.io-client";\n\nfunction wsEmitter() {\n  return eventChannel(emitter => {\n    const socket = io("http://localhost:3001");\n    socket.on("disconnect", reason => {\n      emitter(END);\n      socket.close();\n    });\n    socket.on("message", event => emitter(event));\n    // The subscriber must return an unsubscribe function\n    return () => {\n      socket.close();\n    };\n  });\n}\n\nfunction* wsHandler() {\n  const wsChan = yield effects.call(wsEmitter);\n  while (true) {\n    const event = yield effects.take(wsChan);\n    if (event.type === "create") {\n      yield effects.put({ type: constants.TASK_CREATE, name: event.name });\n    }\n  }\n}\n\nexport function* rootSaga() {\n  yield effects.takeEvery(constants.TASK_PROCESS, processTask);\n  yield effects.fork(wsHandler);\n}'}),l.a.createElement(c.a,{to:"/testing",title:"Go to the next section"}))}},424:function(e,t){e.exports='import { compose, applyMiddleware, createStore } from "redux";\nimport createSagaMiddleware from "redux-saga";\n\nimport { rootSaga } from "./sagas";\nimport reducer from "./reducers";\n\nexport const makeStore = () => {\n  const composeEnhancers =\n    global.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\n  const sagaMiddleware = createSagaMiddleware();\n\n  const store = createStore(\n    reducer,\n    composeEnhancers(applyMiddleware(sagaMiddleware))\n  );\n\n  sagaMiddleware.run(rootSaga);\n\n  return store;\n};\n'},425:function(e,t){e.exports='export function* rootSaga() {\n  console.log("hi from sagas");\n}'}}]);
//# sourceMappingURL=component---src-pages-effects-js-67bf1d53312ef66d9094.js.map